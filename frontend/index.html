<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Games Analytics</title>
    <link href="https://fonts.googleapis.com/css2?family=Motiva+Sans:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.1.0/src/wordcloud2.min.js"></script>
    <style>
        body {
            font-family: 'Motiva Sans', Arial, sans-serif;
            background-color: #1b2838;
            color: #c6d4df;
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: #171a21;
            padding: 20px 0;
            margin-bottom: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-align: center; /* Центрирование заголовка */
        }
        
        h1 {
            color: #ffffff;
            margin: 0;
            font-size: 28px;
        }
        
        .section {
            background-color: #2a3f5a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .section-title {
            color: #67c1f5;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 22px;
        }
        
        .chart-container {
            width: 100%;
            height: 500px;
        }
        
        #wordcloud {
            width: 100%;
            height: 500px;
            background-color: #2a3f5a;
        }
        
        .game-selector {
            margin-bottom: 20px;
        }
        
        select {
            background-color: #2a3f5a;
            color: #c6d4df;
            border: 1px solid #3d556e;
            padding: 8px 12px;
            border-radius: 3px;
            font-size: 16px;
            width: 100%;
            max-width: 400px;
        }
        
        .game-info {
            display: flex;
            margin-bottom: 20px;
        }
        
        .game-image {
            width: 180px;
            height: 80px;
            background-color: #000;
            margin-right: 20px;
            background-size: cover;
            background-position: center;
        }
        
        .game-details {
            flex: 1;
        }
        
        .game-title {
            color: #ffffff;
            font-size: 20px;
            margin: 0 0 10px 0;
        }
        
        .game-meta {
            color: #8f98a0;
            font-size: 14px;
            margin: 5px 0;
        }

        .year-input-wrapper {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .year-label {
            color: #c6d4df;
            font-size: 16px;
            font-weight: 500;
        }

        .year-input {
            background-color: #1b2838;
            border: 1px solid #3c6e94;
            color: #c6d4df;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
            width: 120px;
            transition: border-color 0.3s;
        }

        .year-input:focus {
            border-color: #67c1f5;
        }

        .year-button {
            background-color: #67c1f5;
            color: #1b2838;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .year-button:hover {
            background-color: #4aa3e0;
        }

        
        /* Новые стили для двухколоночного макета */
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .flex-item {
            flex: 1;
            min-width: 300px;
        }
        
        .chart-title {
            color: #67c1f5;
            margin: 20px 0;
            font-size: 22px;
            text-align: center;
        }
        
        #audience-network, #game-audience-network {
            width: 100%;
            height: 500px;
            background-color: #2a3f5a;
            border-radius: 4px;
            margin-bottom: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            position: relative; /* Для правильного позиционирования зума */
            overflow: hidden; /* Чтобы содержимое не выходило за границы при зуме */
        }
        
        /* Стили для слайдера процентов */
        .percentage-slider-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .percentage-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 10px;
            border-radius: 5px;
            background: #1b2838;
            outline: none;
        }
        
        .percentage-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #67c1f5;
            cursor: pointer;
        }
        
        .percentage-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #67c1f5;
            cursor: pointer;
        }
        
        .percentage-value {
            font-size: 16px;
            color: #67c1f5;
            min-width: 60px;
            text-align: center;
        }
        
        .network-stats {
            font-size: 14px;
            color: #8f98a0;
            margin-bottom: 15px;
        }
        
        /* Стили для слайдера масштаба */
        .zoom-slider-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .zoom-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 10px;
            border-radius: 5px;
            background: #1b2838;
            outline: none;
        }
        
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #67c1f5;
            cursor: pointer;
        }
        
        .zoom-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #67c1f5;
            cursor: pointer;
        }
        
        .zoom-value {
            font-size: 16px;
            color: #67c1f5;
            min-width: 60px;
            text-align: center;
        }
        
        /* Стили для контролов визуализации */
        .visualization-controls {
            background-color: #1b2838;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: block;
            margin-bottom: 5px;
            color: #67c1f5;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Steam Games Analytics</h1>
        </div>
    </header>
    
    <div class="container">
        <div class="section">
            <h2 class="section-title">Game Titles Word Cloud</h2>
            <div id="wordcloud"></div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Genres Distribution</h2>
            <div class="year-input-wrapper">
                <label for="year-input" class="year-label">Enter Year:</label>
                <input type="number" id="year-input" class="year-input" min="1980" max="2100" placeholder="e.g. 2020">
                <button id="load-genres-btn" class="year-button">Load</button>
            </div>
            <div id="genres-chart" class="chart-container"></div>
        </div>

        <div class="section">
            <h2 class="section-title">Genres Bubble Chart (All Games)</h2>
            <div id="genres-bubble" class="chart-container"></div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Game Analytics</h2>
            <div class="game-selector">
                <select id="game-select">
                    <option value="">Select a game...</option>
                </select>
            </div>
            
            <div id="game-display" style="display: none;">
                <div class="game-info">
                    <div class="game-image" id="game-image"></div>
                    <div class="game-details">
                        <h3 class="game-title" id="game-title"></h3>
                        <p class="game-meta" id="game-release"></p>
                        <p class="game-meta" id="game-price"></p>
                    </div>
                </div>
                
                <!-- Двухколоночный макет для радара и жанров -->
                <div class="flex-container">
                    <div class="flex-item">
                        <h3 class="section-title">Game Stats</h3>
                        <div id="radar-chart" class="chart-container"></div>
                    </div>
                    <div class="flex-item">
                        <h3 class="section-title">Game Genres</h3>
                        <div id="game-genres-bubble" class="chart-container"></div>
                    </div>
                </div>
                
                <!-- Аудитория для выбранной игры -->
                <h3 class="section-title">Game Audience Overlap</h3>
                <div class="visualization-controls">
                    <div class="control-group">
                        <label class="control-label" for="game-zoom-slider">Zoom Level:</label>
                        <div class="zoom-slider-container">
                            <span>-</span>
                            <input type="range" min="0.1" max="3" step="0.1" value="1" class="zoom-slider" id="game-zoom-slider">
                            <span>+</span>
                            <span class="zoom-value" id="game-zoom-value">100%</span>
                        </div>
                    </div>
                </div>
                <div id="game-audience-network"></div>
            </div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Audience Overlap Network (All Games)</h2>
            
            <!-- Контролы визуализации -->
            <div class="visualization-controls">
                <div class="control-group">
                    <label class="control-label" for="percentage-slider">Percentage of games to display:</label>
                    <div class="percentage-slider-container">
                        <span>10%</span>
                        <input type="range" min="10" max="100" step="10" value="100" class="percentage-slider" id="percentage-slider">
                        <span>100%</span>
                        <span class="percentage-value" id="percentage-value">100%</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="zoom-slider">Zoom Level:</label>
                    <div class="zoom-slider-container">
                        <span>-</span>
                        <input type="range" min="0.1" max="3" step="0.1" value="1" class="zoom-slider" id="zoom-slider">
                        <span>+</span>
                        <span class="zoom-value" id="zoom-value">100%</span>
                    </div>
                </div>
            </div>
            
            <!-- Статистика сети -->
            <div class="network-stats" id="network-stats"></div>
            
            <div id="audience-network"></div>
        </div>
    </div>

    <script>
        // Загрузка данных и инициализация графиков
        document.addEventListener('DOMContentLoaded', async function() {
            // Загружаем данные об играх
            const games = await fetch('/api/games').then(res => res.json());
            
            // Инициализация wordcloud
            initWordCloud();
            
            // Инициализация circular packing для жанров
            initGenresChart();
            
            // Инициализация bubble chart для жанров
            loadGenreData();
            
            // Инициализация сети аудитории для всех игр
            loadAudienceOverlap(100, 1); // По умолчанию 100% и масштаб 1
            
            // Обработчик изменения слайдера процентов
            const percentageSlider = document.getElementById('percentage-slider');
            const percentageValue = document.getElementById('percentage-value');
            
            percentageSlider.addEventListener('input', function() {
                const value = this.value;
                percentageValue.textContent = `${value}%`;
            });
            
            percentageSlider.addEventListener('change', function() {
                const value = this.value;
                const zoomValue = document.getElementById('zoom-slider').value;
                loadAudienceOverlap(value, zoomValue);
            });
            
            // Обработчик изменения слайдера масштаба для общей сети
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            
            zoomSlider.addEventListener('input', function() {
                const value = this.value;
                const zoomPercent = Math.round(value * 100);
                zoomValue.textContent = `${zoomPercent}%`;
                
                // Применяем масштаб к существующей визуализации
                applyZoom('audience-network', value);
            });
            
            zoomSlider.addEventListener('change', function() {
                const value = this.value;
                const percentValue = document.getElementById('percentage-slider').value;
                loadAudienceOverlap(percentValue, value);
            });
            
            // Обработчик изменения слайдера масштаба для сети конкретной игры
            const gameZoomSlider = document.getElementById('game-zoom-slider');
            const gameZoomValue = document.getElementById('game-zoom-value');
            
            gameZoomSlider.addEventListener('input', function() {
                const value = this.value;
                const zoomPercent = Math.round(value * 100);
                gameZoomValue.textContent = `${zoomPercent}%`;
                
                // Применяем масштаб к существующей визуализации
                applyZoom('game-audience-network', value);
            });
            
            // Заполняем выпадающий список игр
            const gameSelect = document.getElementById('game-select');
            games.forEach(game => {
                const option = document.createElement('option');
                option.value = game.steamId;
                option.textContent = game.name;
                gameSelect.appendChild(option);
            });
            
            // Обработчик выбора игры
            gameSelect.addEventListener('change', async function() {
                const steamId = this.value;
                if (!steamId) {
                    document.getElementById('game-display').style.display = 'none';
                    return;
                }
                
                const game = await fetch(`/api/games/${steamId}`).then(res => res.json());
                displayGameInfo(game);
                initRadarChart(game);
                
                // Загружаем жанры для выбранной игры
                loadGameGenreData(steamId);
                
                // Загружаем аудиторию для выбранной игры
                const zoomValue = document.getElementById('game-zoom-slider').value;
                loadGameAudienceOverlap(steamId, zoomValue);
            });
        });
        
        // Функция для применения масштаба к существующей визуализации
        function applyZoom(containerId, zoomLevel) {
            const svg = d3.select(`#${containerId} svg`);
            if (!svg.empty()) {
                const g = svg.select('g.zoom-container');
                if (!g.empty()) {
                    g.attr('transform', `scale(${zoomLevel})`);
                    
                    // Центрируем масштабированное содержимое
                    const container = document.getElementById(containerId);
                    const width = container.clientWidth;
                    const height = container.clientHeight || 500;
                    
                    // Вычисляем смещение для центрирования
                    const offsetX = (width * (1 - zoomLevel)) / 2;
                    const offsetY = (height * (1 - zoomLevel)) / 2;
                    
                    if (zoomLevel !== 1) {
                        g.attr('transform', `translate(${width/2}, ${height/2}) scale(${zoomLevel}) translate(${-width/2}, ${-height/2})`);
                    } else {
                        g.attr('transform', 'translate(0, 0) scale(1)');
                    }
                }
            }
        }
        
        // Word Cloud
        async function initWordCloud() {
            const wordcloudData = await fetch('/api/wordcloud').then(res => res.json());
            
            WordCloud(document.getElementById('wordcloud'), {
                list: wordcloudData.map(item => [item.text, item.value]),
                gridSize: 10,
                weightFactor: 5,
                fontFamily: 'Motiva Sans, Arial, sans-serif',
                color: function (word, weight) {
                    return weight > 15 ? '#67c1f5' : 
                           weight > 10 ? '#c6d4df' : 
                           weight > 5 ? '#8f98a0' : '#626b75';
                },
                backgroundColor: '#2a3f5a',
                rotateRatio: 0.5,
                minSize: 4
            });
        }
        
        // Circular Packing для жанров
        async function initGenresChart(year = null) {
            let url = '/api/genres';
            if (year) {
                url += `?year=${year}`;
            }

            const genresData = await fetch(url).then(res => res.json());

            const chart = echarts.init(document.getElementById('genres-chart'));
            
            const option = {
                backgroundColor: 'transparent',
                series: {
                    type: 'sunburst',
                    data: genresData.children,
                    radius: [0, '85%'],
                    sort: null,
                    emphasis: {
                        focus: 'ancestor'
                    },
                    label: {
                        color: '#c6d4df',
                        fontSize: 14,
                        rotate: 'radial'
                    },
                    itemStyle: {
                        color: function(params) {
                            const steamColors = [
                                '#67c1f5', '#1a9fff', '#4b6b82', 
                                '#5d7b93', '#66a1c9', '#417a9b',
                                '#9ecdf2', '#3e6b89', '#7aa8d4'
                            ];
                            return steamColors[params.dataIndex % steamColors.length];
                        },
                        borderWidth: 2,
                        borderColor: '#2a475e'
                    },
                    levels: [
                        {},
                        {
                            r0: '15%',
                            r: '35%',
                            label: { rotate: 'tangential', color: '#c7d5e0' },
                            itemStyle: { borderWidth: 2 }
                        },
                        {
                            r0: '35%',
                            r: '65%',
                            label: { color: '#acdbf5', align: 'right' },
                            itemStyle: { borderWidth: 2 }
                        },
                        {
                            r0: '65%',
                            r: '85%',
                            label: {
                                position: 'outside',
                                padding: 3,
                                color: '#67c1f5',
                                fontWeight: 'bold',
                                fontSize: 13
                            },
                            itemStyle: { borderWidth: 3 }
                        }
                    ]
                }
            };

            const yearSelect = document.getElementById('year-select');

            chart.setOption(option);

            window.addEventListener('resize', function () {
                chart.resize();
            });
        }
        
        // Отображение информации об игре
        function displayGameInfo(game) {
            document.getElementById('game-display').style.display = 'block';
            document.getElementById('game-title').textContent = game.name;
            document.getElementById('game-release').textContent = `Release Date: ${game.releaseDate}`;
            document.getElementById('game-price').textContent = `Price: ${game.price}`;
            
            // Здесь можно добавить изображение игры, если есть URL
            // document.getElementById('game-image').style.backgroundImage = `url(${game.imageUrl})`;
        }
        
        // Radar Chart для анализа игры
        function initRadarChart(game) {
            const chart = echarts.init(document.getElementById('radar-chart'));
            
            // Нормализуем данные для радарной диаграммы
            const maxValues = {
                price: 60,  // Максимальная цена для нормализации
                reviews: Math.max(game.reviews, 500000),
                reviewScore: 100,
                followers: Math.max(game.followers, 1000000),
                avgPlaytime: Math.max(game.avgPlaytime, 100)
            };
            
            const indicator = [
                { name: 'Price (lower is better)', max: maxValues.price },
                { name: 'Reviews', max: maxValues.reviews },
                { name: 'Score', max: maxValues.reviewScore },
                { name: 'Followers', max: maxValues.followers },
                { name: 'Avg Playtime', max: maxValues.avgPlaytime }
            ];
            
            const data = [
                {
                    value: [
                        maxValues.price - game.price,  // Инвертируем цену (чем ниже тем лучше)
                        game.reviews,
                        game.reviewScore,
                        game.followers,
                        game.avgPlaytime
                    ],
                    name: game.name
                }
            ];
            
            const option = {
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'item'
                },
                legend: {
                    data: [game.name],
                    textStyle: {
                        color: '#c6d4df'
                    },
                    bottom: 0
                },
                radar: {
                    indicator: indicator,
                    shape: 'circle',
                    splitNumber: 5,
                    axisName: {
                        color: '#c6d4df',
                        fontSize: 12
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(198, 212, 223, 0.3)'
                        }
                    },
                    splitArea: {
                        show: false
                    },
                    axisLine: {
                        lineStyle: {
                            color: 'rgba(198, 212, 223, 0.3)'
                        }
                    }
                },
                series: [
                    {
                        name: game.name,
                        type: 'radar',
                        data: data,
                        areaStyle: {
                            color: 'rgba(103, 193, 245, 0.4)'
                        },
                        lineStyle: {
                            color: 'rgba(103, 193, 245, 0.8)',
                            width: 2
                        },
                        symbolSize: 6,
                        itemStyle: {
                            color: '#67c1f5'
                        }
                    }
                ]
            };
            
            chart.setOption(option);
            
            window.addEventListener('resize', function() {
                chart.resize();
            });
        }

        // --- Audience Overlap Network для всех игр ---
        async function loadAudienceOverlap(percentage = 100, zoomLevel = 1) {
            try {
                // Очищаем предыдущую визуализацию
                d3.select("#audience-network svg").remove();
                
                const response = await fetch(`/api/audience-overlap?percentage=${percentage}`);
                const data = await response.json();
                
                // Обновляем статистику сети
                const statsElement = document.getElementById('network-stats');
                statsElement.textContent = `Displaying ${data.displayedGames} out of ${data.totalGames} games (${data.percentage}%) with ${data.nodes.length} nodes and ${data.links.length} connections`;
                
                renderAudienceNetwork(data, "audience-network", zoomLevel);
            } catch (error) {
                console.error("Error loading audience overlap:", error);
            }
        }
        
        // --- Audience Overlap Network для выбранной игры ---
        async function loadGameAudienceOverlap(steamId, zoomLevel = 1) {
            try {
                // Очищаем предыдущую визуализация
                d3.select("#game-audience-network svg").remove();
                
                const response = await fetch(`/api/audience-overlap/${steamId}`);
                const data = await response.json();
                renderAudienceNetwork(data, "game-audience-network", zoomLevel);
            } catch (error) {
                console.error("Error loading game audience overlap:", error);
            }
        }

        // D3.js Circular Packing для жанров всех игр
        async function loadGenreData() {
            const genresData = await fetch('/api/genres').then(res => res.json());
            renderGenreBubbleChart(genresData, "genres-bubble");
        }
        
        // D3.js Circular Packing для жанров выбранной игры
        async function loadGameGenreData(steamId) {
            try {
                // Очищаем предыдущую визуализацию
                d3.select("#game-genres-bubble svg").remove();
                
                const genresData = await fetch(`/api/genres/${steamId}`).then(res => res.json());
                renderGenreBubbleChart(genresData, "game-genres-bubble");
            } catch (error) {
                console.error("Error loading game genres:", error);
            }
        }
        
        // Общая функция для рендеринга bubble chart жанров
        function renderGenreBubbleChart(genresData, containerId) {
            // Prepare data for circular packing
            const packableData = {
                name: "Genres",
                children: genresData.children.map(genre => ({
                    name: genre.name,
                    value: genre.value || 100, // Use value if available or default
                    color: genre.itemStyle?.color || "#67c1f5" // Use color if available or default
                }))
            };
            
            const container = document.getElementById(containerId);
            const width = container.clientWidth;
            const height = 500;
            const sizeDivisor = 20;
            const nodePadding = 2.5;
            
            // Clear any existing SVG
            d3.select(`#${containerId} svg`).remove();
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto;");
            
            // Create a color scale
            const color = d3.scaleOrdinal()
                .domain(packableData.children.map(d => d.name))
                .range(["#1a9fff", "#67c1f5", "#417a9b", "#4b6b82", "#5d7b93", "#6d8ba3"]);
            
            // Process the data to add radius
            const processedData = packableData.children.map(d => {
                return {
                    name: d.name,
                    value: d.value,
                    size: d.value / sizeDivisor,
                    radius: Math.max(d.value / sizeDivisor, 10), // Minimum radius of 10
                    color: d.color
                };
            }).sort((a, b) => b.value - a.value); // Sort so bigger bubbles are drawn first
            
            // Create the simulation
            const simulation = d3.forceSimulation(processedData)
                .force("forceX", d3.forceX().strength(0.1).x(width * 0.5))
                .force("forceY", d3.forceY().strength(0.1).y(height * 0.5))
                .force("center", d3.forceCenter().x(width * 0.5).y(height * 0.5))
                .force("charge", d3.forceManyBody().strength(-15))
                .force("collide", d3.forceCollide().strength(0.5).radius(d => d.radius + nodePadding).iterations(1));
            
            // Create a group for nodes
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(processedData)
                .join("g")
                .attr("transform", d => `translate(${width/2},${height/2})`)
                .call(drag(simulation));
            
            // Add circles to each node
            node.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color || color(d.name))
                .attr("stroke", "#1b2838")
                .attr("stroke-width", 1.5)
                .attr("fill-opacity", 0.8);
            
            // Add text labels to each node
            node.append("text")
                .text(d => d.name)
                .attr("font-size", d => Math.min(d.radius * 0.8, 14))
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .attr("fill", "#ffffff")
                .style("pointer-events", "none")
                .style("text-shadow", "0 1px 2px rgba(0,0,0,0.8)");
            
            // Update positions on simulation tick
            simulation.on("tick", () => {
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });
              () => {
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            };
            
            // Handle window resize
            window.addEventListener("resize", () => {
                const newWidth = container.clientWidth;
                svg.attr("width", newWidth);
                simulation.force("forceX", d3.forceX().strength(0.1).x(newWidth * 0.5));
                simulation.force("center", d3.forceCenter().x(newWidth * 0.5).y(height * 0.5));
                simulation.alpha(0.3).restart();
            });
            
            // Drag functions
            function drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
                
                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }

        // Общая функция для рендеринга сети аудитории
        function renderAudienceNetwork(data, containerId, zoomLevel = 1) {
            // Очищаем предыдущую визуализацию
            d3.select(`#${containerId} svg`).remove();
            
            const container = document.getElementById(containerId);
            const width = container.clientWidth;
            const height = 500;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Создаем группу для масштабирования
            const zoomContainer = svg.append("g")
                .attr("class", "zoom-container");

            const color = d3.scaleOrdinal(d3.schemeCategory10);

            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links).id(d => d.id).distance(d => 200 * (1 - d.value)))
                .force("charge", d3.forceManyBody().strength(-250))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = zoomContainer.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(data.links)
                .join("line")
                .attr("stroke-width", d => d.value * 4);

            const node = zoomContainer.append("g")
                .selectAll("circle")
                .data(data.nodes)
                .join("circle")
                .attr("r", 20)
                .attr("fill", (d, i) => color(i))
                .call(drag(simulation));

            const label = zoomContainer.append("g")
                .selectAll("text")
                .data(data.nodes)
                .join("text")
                .text(d => d.name)
                .attr("font-size", 10)
                .attr("text-anchor", "middle")
                .attr("dy", 4)
                .style("pointer-events", "none");

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // Применяем начальный масштаб
            if (zoomLevel !== 1) {
                zoomContainer.attr('transform', `translate(${width/2}, ${height/2}) scale(${zoomLevel}) translate(${-width/2}, ${-height/2})`);
            }

            // Handle window resize
            window.addEventListener("resize", () => {
                const newWidth = container.clientWidth;
                svg.attr("width", newWidth);
                simulation.force("center", d3.forceCenter(newWidth / 2, height / 2));
                simulation.alpha(0.3).restart();
                
                // Обновляем трансформацию при изменении размера окна
                if (zoomLevel !== 1) {
                    zoomContainer.attr('transform', `translate(${newWidth/2}, ${height/2}) scale(${zoomLevel}) translate(${-newWidth/2}, ${-height/2})`);
                }
            });

            function drag(simulation) {
                return d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });
            }
        }
        document.getElementById('load-genres-btn').addEventListener('click', () => {
            const yearInput = document.getElementById('year-input').value;
            const year = yearInput.trim() === '' ? null : parseInt(yearInput);
            initGenresChart(year);
        });
        document.getElementById('year-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('load-genres-btn').click();
            }
        });
    </script>
</body>
</html>
