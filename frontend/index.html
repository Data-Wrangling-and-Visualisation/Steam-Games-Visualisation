<!DOCTYPE
html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Games Analytics</title>
    <link href="https://fonts.googleapis.com/css2?family=Motiva+Sans:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wordcloud@1.1.0/src/wordcloud2.min.js"></script>
    <style>
        body {
            font-family: 'Motiva Sans', Arial, sans-serif;
            background-color: #1b2838;
            color: #c6d4df;
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: #171a21;
            padding: 20px 0;
            margin-bottom: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            color: #ffffff;
            margin: 0;
            font-size: 28px;
        }
        
        .section {
            background-color: #2a3f5a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .section-title {
            color: #67c1f5;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 22px;
        }
        
        .chart-container {
            width: 100%;
            height: 500px;
        }
        
        #wordcloud {
            width: 100%;
            height: 500px;
            background-color: #2a3f5a;
        }
        
        .game-selector {
            margin-bottom: 20px;
        }
        
        select {
            background-color: #2a3f5a;
            color: #c6d4df;
            border: 1px solid #3d556e;
            padding: 8px 12px;
            border-radius: 3px;
            font-size: 16px;
            width: 100%;
            max-width: 400px;
        }
        
        .game-info {
            display: flex;
            margin-bottom: 20px;
        }
        
        .game-image {
            width: 180px;
            height: 80px;
            background-color: #000;
            margin-right: 20px;
            background-size: cover;
            background-position: center;
        }
        
        .game-details {
            flex: 1;
        }
        
        .game-title {
            color: #ffffff;
            font-size: 20px;
            margin: 0 0 10px 0;
        }
        
        .game-meta {
            color: #8f98a0;
            font-size: 14px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Steam Games Analytics</h1>
        </div>
    </header>
    
    <div class="container">
        <div class="section">
            <h2 class="section-title">Game Titles Word Cloud</h2>
            <div id="wordcloud"></div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Genres Distribution</h2>
            <div id="genres-chart" class="chart-container"></div>
        </div>

        <div class="section">
            <h2 class="section-title">Genres Bubble Chart</h2>
            <div id="genres-bubble" class="chart-container"></div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Game Analytics</h2>
            <div class="game-selector">
                <select id="game-select">
                    <option value="">Select a game...</option>
                </select>
            </div>
            
            <div id="game-display" style="display: none;">
                <div class="game-info">
                    <div class="game-image" id="game-image"></div>
                    <div class="game-details">
                        <h3 class="game-title" id="game-title"></h3>
                        <p class="game-meta" id="game-release"></p>
                        <p class="game-meta" id="game-price"></p>
                    </div>
                </div>
                
                <div id="radar-chart" class="chart-container"></div>
            </div>
        </div>
    </div>
    

    <h2 class="chart-title">Audience Overlap Network</h2>
    <div id="audience-network"></div>

    <script>
        // Загрузка данных и инициализация графиков
        document.addEventListener('DOMContentLoaded', async function() {
            // Загружаем данные об играх
            const games = await fetch('/api/games').then(res => res.json());
            
            // Инициализация wordcloud
            initWordCloud();
            
            // Инициализация circular packing для жанров
            initGenresChart();
            
            // Заполняем выпадающий список игр
            const gameSelect = document.getElementById('game-select');
            games.forEach(game => {
                const option = document.createElement('option');
                option.value = game.steamId;
                option.textContent = game.name;
                gameSelect.appendChild(option);
            });
            
            // Обработчик выбора игры
            gameSelect.addEventListener('change', async function() {
                const steamId = this.value;
                if (!steamId) {
                    document.getElementById('game-display').style.display = 'none';
                    return;
                }
                
                const game = await fetch(`/api/games/${steamId}`).then(res => res.json());
                displayGameInfo(game);
                initRadarChart(game);
            });
        });
        
        // Word Cloud
        async function initWordCloud() {
            const wordcloudData = await fetch('/api/wordcloud').then(res => res.json());
            
            WordCloud(document.getElementById('wordcloud'), {
                list: wordcloudData.map(item => [item.text, item.value]),
                gridSize: 10,
                weightFactor: 5,
                fontFamily: 'Motiva Sans, Arial, sans-serif',
                color: function (word, weight) {
                    return weight > 15 ? '#67c1f5' : 
                           weight > 10 ? '#c6d4df' : 
                           weight > 5 ? '#8f98a0' : '#626b75';
                },
                backgroundColor: '#2a3f5a',
                rotateRatio: 0.5,
                minSize: 4
            });
        }
        
        // Circular Packing для жанров
        async function initGenresChart() {
            const genresData = await fetch('/api/genres').then(res => res.json());
            
            const chart = echarts.init(document.getElementById('genres-chart'));
            
            const option = {
                backgroundColor: 'transparent',
                series: {
                    type: 'sunburst',
                    data: genresData.children,
                    radius: [0, '90%'],
                    label: {
                        color: '#c6d4df',
                        fontSize: 14
                    },
                    itemStyle: {
                        color: function(params) {
                            const colors = [
                                '#1a9fff', '#67c1f5', '#417a9b', 
                                '#4b6b82', '#5d7b93', '#6d8ba3'
                            ];
                            return colors[params.dataIndex % colors.length];
                        },
                        borderWidth: 2,
                        borderColor: '#1b2838'
                    },
                    levels: [
                        {},
                        {
                            r0: '15%',
                            r: '45%',
                            itemStyle: {
                                borderWidth: 2
                            },
                            label: {
                                rotate: 'tangential'
                            }
                        },
                        {
                            r0: '45%',
                            r: '80%',
                            label: {
                                align: 'right'
                            }
                        },
                        {
                            r0: '80%',
                            r: '90%',
                            label: {
                                position: 'outside',
                                padding: 3,
                                silent: false
                            },
                            itemStyle: {
                                borderWidth: 3
                            }
                        }
                    ]
                }
            };
            
            chart.setOption(option);
            
            window.addEventListener('resize', function() {
                chart.resize();
            });
        }
        
        // Отображение информации об игре
        function displayGameInfo(game) {
            document.getElementById('game-display').style.display = 'block';
            document.getElementById('game-title').textContent = game.name;
            document.getElementById('game-release').textContent = `Release Date: ${game.releaseDate}`;
            document.getElementById('game-price').textContent = `Price: $${game.price}`;
            
            // Здесь можно добавить изображение игры, если есть URL
            // document.getElementById('game-image').style.backgroundImage = `url(${game.imageUrl})`;
        }
        
        // Radar Chart для анализа игры
        function initRadarChart(game) {
            const chart = echarts.init(document.getElementById('radar-chart'));
            
            // Нормализуем данные для радарной диаграммы
            const maxValues = {
                price: 60,  // Максимальная цена для нормализации
                reviews: Math.max(game.reviews, 500000),
                reviewScore: 100,
                followers: Math.max(game.followers, 1000000),
                avgPlaytime: Math.max(game.avgPlaytime, 100)
            };
            
            const indicator = [
                { name: 'Price (lower is better)', max: maxValues.price },
                { name: 'Reviews', max: maxValues.reviews },
                { name: 'Score', max: maxValues.reviewScore },
                { name: 'Followers', max: maxValues.followers },
                { name: 'Avg Playtime', max: maxValues.avgPlaytime }
            ];
            
            const data = [
                {
                    value: [
                        maxValues.price - game.price,  // Инвертируем цену (чем ниже тем лучше)
                        game.reviews,
                        game.reviewScore,
                        game.followers,
                        game.avgPlaytime
                    ],
                    name: game.name
                }
            ];
            
            const option = {
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'item'
                },
                legend: {
                    data: [game.name],
                    textStyle: {
                        color: '#c6d4df'
                    },
                    bottom: 0
                },
                radar: {
                    indicator: indicator,
                    shape: 'circle',
                    splitNumber: 5,
                    axisName: {
                        color: '#c6d4df',
                        fontSize: 12
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(198, 212, 223, 0.3)'
                        }
                    },
                    splitArea: {
                        show: false
                    },
                    axisLine: {
                        lineStyle: {
                            color: 'rgba(198, 212, 223, 0.3)'
                        }
                    }
                },
                series: [
                    {
                        name: game.name,
                        type: 'radar',
                        data: data,
                        areaStyle: {
                            color: 'rgba(103, 193, 245, 0.4)'
                        },
                        lineStyle: {
                            color: 'rgba(103, 193, 245, 0.8)',
                            width: 2
                        },
                        symbolSize: 6,
                        itemStyle: {
                            color: '#67c1f5'
                        }
                    }
                ]
            };
            
            chart.setOption(option);
            
            window.addEventListener('resize', function() {
                chart.resize();
            });
        }
 

// --- Audience Overlap Network ---
async function loadAudienceOverlap() {
    const response = await fetch("/api/audience-overlap");
    const data = await response.json();
    renderAudienceNetwork(data);
}

// D3.js Circular Packing для жанров
async function loadGenreData() {
    const genresData = await fetch('/api/genres').then(res => res.json());
    
    // Prepare data for circular packing
    const packableData = {
        name: "Genres",
        children: genresData.children.map(genre => ({
            name: genre.name,
            value: genre.value || 100, // Use value if available or default
            color: genre.itemStyle?.color || "#67c1f5" // Use color if available or default
        }))
    };
    
    const width = document.getElementById('genres-bubble').clientWidth;
    const height = 500;
    const sizeDivisor = 20;
    const nodePadding = 2.5;
    
    // Clear any existing SVG
    d3.select("#genres-bubble svg").remove();
    
    const svg = d3.select("#genres-bubble")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto;");
    
    // Create a color scale
    const color = d3.scaleOrdinal()
        .domain(packableData.children.map(d => d.name))
        .range(["#1a9fff", "#67c1f5", "#417a9b", "#4b6b82", "#5d7b93", "#6d8ba3"]);
    
    // Process the data to add radius
    const processedData = packableData.children.map(d => {
        return {
            name: d.name,
            value: d.value,
            size: d.value / sizeDivisor,
            radius: Math.max(d.value / sizeDivisor, 10), // Minimum radius of 10
            color: d.color
        };
    }).sort((a, b) => b.value - a.value); // Sort so bigger bubbles are drawn first
    
    // Create the simulation
    const simulation = d3.forceSimulation(processedData)
        .force("forceX", d3.forceX().strength(0.1).x(width * 0.5))
        .force("forceY", d3.forceY().strength(0.1).y(height * 0.5))
        .force("center", d3.forceCenter().x(width * 0.5).y(height * 0.5))
        .force("charge", d3.forceManyBody().strength(-15))
        .force("collide", d3.forceCollide().strength(0.5).radius(d => d.radius + nodePadding).iterations(1));
    
    // Create a group for nodes
    const node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(processedData)
        .join("g")
        .attr("transform", d => `translate(${width/2},${height/2})`)
        .call(drag(simulation));
    
    // Add circles to each node
    node.append("circle")
        .attr("r", d => d.radius)
        .attr("fill", d => d.color || color(d.name))
        .attr("stroke", "#1b2838")
        .attr("stroke-width", 1.5)
        .attr("fill-opacity", 0.8);
    
    // Add text labels to each node
    node.append("text")
        .text(d => d.name)
        .attr("font-size", d => Math.min(d.radius * 0.8, 14))
        .attr("text-anchor", "middle")
        .attr("dy", ".35em")
        .attr("fill", "#ffffff")
        .style("pointer-events", "none")
        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.8)");
    
    // Update positions on simulation tick
    simulation.on("tick", () => {
        node.attr("transform", d => `translate(${d.x},${d.y})`);
    });
    
    // Handle window resize
    window.addEventListener("resize", () => {
        const newWidth = document.getElementById('genres-bubble').clientWidth;
        svg.attr("width", newWidth);
        simulation.force("forceX", d3.forceX().strength(0.1).x(newWidth * 0.5));
        simulation.force("center", d3.forceCenter().x(newWidth * 0.5).y(height * 0.5));
        simulation.alpha(0.3).restart();
    });
    
    // Drag functions
    function drag(simulation) {
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }
}

function renderAudienceNetwork(data) {
    const width = 700;
    const height = 500;
    const svg = d3.select("#audience-network")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    const color = d3.scaleOrdinal(d3.schemeCategory10);

    const simulation = d3.forceSimulation(data.nodes)
        .force("link", d3.forceLink(data.links).id(d => d.id).distance(d => 200 * (1 - d.value)))
        .force("charge", d3.forceManyBody().strength(-250))
        .force("center", d3.forceCenter(width / 2, height / 2));

    const link = svg.append("g")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
        .selectAll("line")
        .data(data.links)
        .join("line")
        .attr("stroke-width", d => d.value * 4);

    const node = svg.append("g")
        .selectAll("circle")
        .data(data.nodes)
        .join("circle")
        .attr("r", 20)
        .attr("fill", (d, i) => color(i))
        .call(drag(simulation));

    const label = svg.append("g")
        .selectAll("text")
        .data(data.nodes)
        .join("text")
        .text(d => d.name)
        .attr("font-size", 10)
        .attr("text-anchor", "middle")
        .attr("dy", 4)
        .style("pointer-events", "none");

    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        label
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    });

    function drag(simulation) {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
}

// Добавляем вызовы этих функций в основной блок загрузки
document.addEventListener('DOMContentLoaded', async function() {
    const games = await fetch('/api/games').then(res => res.json());

    initWordCloud();
    initGenresChart(); // sunburst
    loadGenreData();   // D3 packing
    loadAudienceOverlap();

    const gameSelect = document.getElementById('game-select');
    games.forEach(game => {
        const option = document.createElement('option');
        option.value = game.steamId;
        option.textContent = game.name;
        gameSelect.appendChild(option);
    });

    gameSelect.addEventListener('change', async function() {
        const steamId = this.value;
        if (!steamId) {
            document.getElementById('game-display').style.display = 'none';
            return;
        }

        const game = await fetch(`/api/games/${steamId}`).then(res => res.json());
        displayGameInfo(game);
        initRadarChart(game);
    });
});

    </script>
</body>
</html>
